import { getCollection } from "astro:content";
import type { Entry, Group, Sidebar } from "./docs/types";

interface DocEntry {
  id: string;
  slug: string;
  data: {
    title: string;
    navLabel?: string;
    navIcon?: string;
    navOrder?: number;
    navHidden?: boolean;
  };
}

interface ProcessedEntry extends Entry {
  label: string;
  order?: number;
}

interface ProcessedGroup extends Group {
  groups: ProcessedGroup[];
  entries: ProcessedEntry[];
}

/**
 * Get all documentation entries from the filesystem
 */
async function getDocsFromFilesystem(): Promise<DocEntry[]> {
  const docs = await getCollection("docs");
  return docs.map((doc) => ({
    id: doc.id,
    slug: doc.id, // Using id as slug for the loader-based collection
    data: {
      title: doc.data.title,
      navLabel: doc.data.navLabel,
      navIcon: doc.data.navIcon,
      navOrder: doc.data.navOrder,
      navHidden: doc.data.navHidden,
    },
  }));
}

/**
 * Extract folder structure from filesystem entries
 */
function buildFilesystemStructure(docs: DocEntry[]): Map<string, DocEntry[]> {
  const structure = new Map<string, DocEntry[]>();

  docs.forEach((doc) => {
    const parts = doc.slug.split("/");

    // Add to root
    if (parts.length === 1) {
      const root = structure.get("") || [];
      root.push(doc);
      structure.set("", root);
    }

    // Add to each folder level
    for (let i = 0; i < parts.length - 1; i++) {
      const folderPath = parts.slice(0, i + 1).join("/");
      const entries = structure.get(folderPath) || [];

      // Only add if this file belongs directly to this folder
      if (i === parts.length - 2) {
        entries.push(doc);
        structure.set(folderPath, entries);
      }
    }
  });

  return structure;
}

/**
 * Process a group and its entries according to autoGenerated rules
 */
function processGroup(
  group: Group,
  filesystemStructure: Map<string, DocEntry[]>,
  allDocs: DocEntry[]
): ProcessedGroup {
  const autoGenerated = group.autoGenerated ?? true;
  const groupPath = group.path || group.id;

  // Get filesystem entries for this group's path
  const filesystemEntries = filesystemStructure.get(groupPath) || [];

  // Process configured entries
  const configuredEntries: ProcessedEntry[] = [];
  const configuredSlugs = new Set<string>();

  if (group.entries) {
    group.entries.forEach((entry) => {
      configuredSlugs.add(entry.slug);

      // Find the doc for this entry
      const doc = allDocs.find((d) => d.slug === entry.slug);

      if (!doc) {
        console.warn(`Entry ${entry.slug} not found in docs collection`);
        return;
      }

      // Skip hidden entries
      if (entry.hidden || doc.data.navHidden) {
        return;
      }

      configuredEntries.push({
        slug: entry.slug,
        label: entry.label || doc.data.navLabel || doc.data.title,
        icon: entry.icon || doc.data.navIcon,
        hidden: false,
        order: doc.data.navOrder,
      });
    });
  }

  // Handle auto-generated entries
  let finalEntries = [...configuredEntries];

  if (autoGenerated) {
    // Add unlisted filesystem entries
    const autoEntries: ProcessedEntry[] = filesystemEntries
      .filter((doc) => !configuredSlugs.has(doc.slug) && !doc.data.navHidden)
      .map((doc) => ({
        slug: doc.slug,
        label: doc.data.navLabel || doc.data.title,
        icon: doc.data.navIcon,
        order: doc.data.navOrder,
      }))
      .sort((a, b) => a.label.localeCompare(b.label));

    finalEntries = [...configuredEntries, ...autoEntries];
  }

  // Process subgroups recursively
  const processedSubgroups: ProcessedGroup[] = [];
  if (group.groups) {
    group.groups.forEach((subgroup) => {
      processedSubgroups.push(processGroup(subgroup, filesystemStructure, allDocs));
    });
  }

  return {
    ...group,
    groups: processedSubgroups,
    entries: finalEntries,
  };
}

/**
 * Compute tabs from the navigation structure
 */
export interface Tab {
  id: string;
  label: string;
  icon?: string;
  group: ProcessedGroup;
}

export interface NavigationResult {
  tabs: Tab[];
  showTabs: boolean;
  defaultTab?: Tab;
}

/**
 * Build the complete navigation structure
 */
export async function buildNavigation(config: Sidebar): Promise<NavigationResult> {
  // Get all docs from filesystem
  const allDocs = await getDocsFromFilesystem();
  const filesystemStructure = buildFilesystemStructure(allDocs);

  // Process all groups
  const processedGroups = config.groups.map((group) =>
    processGroup(group, filesystemStructure, allDocs)
  );

  // Collect all tabs recursively (including nested groups with tab: true)
  function collectTabs(groups: ProcessedGroup[]): ProcessedGroup[] {
    const tabs: ProcessedGroup[] = [];

    groups.forEach((group) => {
      if (group.tab === true) {
        tabs.push(group);
      }
      // Recursively check subgroups
      if (group.groups && group.groups.length > 0) {
        tabs.push(...collectTabs(group.groups));
      }
    });

    return tabs;
  }

  // Collect all groups that should be tabs (at any level)
  const allTabGroups = collectTabs(processedGroups);

  // Remove tab groups from their parent groups and clean up the hierarchy
  function removeTabGroups(groups: ProcessedGroup[]): ProcessedGroup[] {
    return groups
      .filter((group) => group.tab !== true)
      .map((group) => {
        if (group.groups && group.groups.length > 0) {
          // Filter out groups that are tabs and recursively process remaining groups
          const nonTabSubgroups = group.groups.filter((g) => g.tab !== true);
          return {
            ...group,
            groups: removeTabGroups(nonTabSubgroups),
          };
        }
        return group;
      });
  }

  // For tabs that have subgroups, also remove nested tabs from their structure
  const cleanedTabGroups = allTabGroups.map((tabGroup) => {
    if (tabGroup.groups && tabGroup.groups.length > 0) {
      const nonTabSubgroups = tabGroup.groups.filter((g) => g.tab !== true);
      return {
        ...tabGroup,
        groups: removeTabGroups(nonTabSubgroups),
      };
    }
    return tabGroup;
  });

  // Get non-tab groups (with tab groups removed from hierarchy)
  const defaultGroups = removeTabGroups(processedGroups);

  // Create tabs
  const tabs: Tab[] = cleanedTabGroups.map((group) => ({
    id: group.id,
    label: group.label,
    icon: group.icon,
    group: group,
  }));

  // Create default tab if there are non-tab groups
  let defaultTab: Tab | undefined;
  if (defaultGroups.length > 0) {
    defaultTab = {
      id: "_default",
      label: "Docs",
      group: {
        id: "_default",
        label: "Docs",
        groups: defaultGroups,
        entries: [],
      },
    };
  }

  // Determine if we should show tabs
  const visibleTabs = defaultTab ? [defaultTab, ...tabs] : tabs;
  const showTabs = visibleTabs.length >= 2;

  return {
    tabs: visibleTabs,
    showTabs,
    defaultTab,
  };
}

/**
 * Get the active tab based on the current page slug
 */
export function getActiveTab(slug: string, tabs: Tab[]): Tab | undefined {
  // Find which tab contains this slug
  for (const tab of tabs) {
    if (containsSlug(tab.group, slug)) {
      return tab;
    }
  }

  return tabs.find((t) => t.id === "_default") || tabs[0];
}

/**
 * Check if a group contains a specific slug
 */
function containsSlug(group: ProcessedGroup, slug: string): boolean {
  // Check direct entries
  if (group.entries?.some((e) => e.slug === slug)) {
    return true;
  }

  // Check subgroups recursively
  if (group.groups) {
    for (const subgroup of group.groups) {
      if (containsSlug(subgroup, slug)) {
        return true;
      }
    }
  }

  return false;
}
