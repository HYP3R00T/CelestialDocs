import { getCollection } from "astro:content";
import type { Entry, Group, Sidebar } from "./docs/types";

interface DocEntry {
  id: string;
  slug: string;
  data: {
    title: string;
    navLabel?: string;
    navIcon?: string;
    navOrder?: number;
    navHidden?: boolean;
  };
}

interface ProcessedEntry extends Entry {
  label: string;
  order?: number;
}

interface ProcessedGroup extends Group {
  groups: ProcessedGroup[];
  entries: ProcessedEntry[];
  // Optional ordered children when we need to preserve interleaved entries and groups
  children?: Array<ProcessedGroup | ProcessedEntry>;
}

/**
 * Get all documentation entries from the filesystem
 */
async function getDocsFromFilesystem(): Promise<DocEntry[]> {
  const docs = await getCollection("docs");
  return docs.map((doc) => ({
    id: doc.id,
    slug: doc.id, // Using id as slug for the loader-based collection
    data: {
      title: doc.data.title,
      navLabel: doc.data.navLabel,
      navIcon: doc.data.navIcon,
      navOrder: doc.data.navOrder,
      navHidden: doc.data.navHidden,
    },
  }));
}

/**
 * Extract folder structure from filesystem entries
 */
function buildFilesystemStructure(docs: DocEntry[]): Map<string, DocEntry[]> {
  const structure = new Map<string, DocEntry[]>();

  docs.forEach((doc) => {
    const parts = doc.slug.split("/");

    // Add to root
    if (parts.length === 1) {
      const root = structure.get("") || [];
      root.push(doc);
      structure.set("", root);
    }

    // Add to each folder level
    for (let i = 0; i < parts.length - 1; i++) {
      const folderPath = parts.slice(0, i + 1).join("/");
      const entries = structure.get(folderPath) || [];

      // Only add if this file belongs directly to this folder
      if (i === parts.length - 2) {
        entries.push(doc);
        structure.set(folderPath, entries);
      }
    }
  });

  return structure;
}

/**
 * Process a group and its entries according to autoGenerated rules
 */
function processGroup(
  group: Group,
  filesystemStructure: Map<string, DocEntry[]>,
  allDocs: DocEntry[]
): ProcessedGroup {
  const autoGenerated = group.autoGenerated ?? true;
  // Respect an explicit empty-string path (root) â€” if path is undefined use id
  const groupPath = group.path !== undefined ? group.path : group.id;

  // Get filesystem entries for this group's path
  const filesystemEntries = filesystemStructure.get(groupPath) || [];

  // Process configured entries
  const configuredEntries: ProcessedEntry[] = [];
  const configuredSlugs = new Set<string>();

  if (group.entries) {
    group.entries.forEach((entry) => {
      configuredSlugs.add(entry.slug);

      // Find the doc for this entry
      const doc = allDocs.find((d) => d.slug === entry.slug);

      if (!doc) {
        console.warn(`Entry ${entry.slug} not found in docs collection`);
        return;
      }

      // Skip hidden entries
      if (entry.hidden || doc.data.navHidden) {
        return;
      }

      configuredEntries.push({
        slug: entry.slug,
        label: entry.label || doc.data.navLabel || doc.data.title,
        icon: entry.icon || doc.data.navIcon,
        hidden: false,
        order: doc.data.navOrder,
      });
    });
  }

  // Handle auto-generated entries
  let finalEntries = [...configuredEntries];

  if (autoGenerated) {
    // Add unlisted filesystem entries
    const autoEntries: ProcessedEntry[] = filesystemEntries
      .filter((doc) => !configuredSlugs.has(doc.slug) && !doc.data.navHidden)
      .map((doc) => ({
        slug: doc.slug,
        label: doc.data.navLabel || doc.data.title,
        icon: doc.data.navIcon,
        order: doc.data.navOrder,
      }))
      .sort((a, b) => a.label.localeCompare(b.label));

    finalEntries = [...configuredEntries, ...autoEntries];
  }

  // Process subgroups recursively
  const processedSubgroups: ProcessedGroup[] = [];
  if (group.groups) {
    group.groups.forEach((subgroup) => {
      processedSubgroups.push(processGroup(subgroup, filesystemStructure, allDocs));
    });
  }

  return {
    ...group,
    groups: processedSubgroups,
    entries: finalEntries,
  };
}

/**
 * Compute tabs from the navigation structure
 */
export interface Tab {
  id: string;
  label: string;
  icon?: string;
  group: ProcessedGroup;
}

export interface NavigationResult {
  tabs: Tab[];
  showTabs: boolean;
  defaultTab?: Tab;
}

/**
 * Build the complete navigation structure
 */
export async function buildNavigation(config: Sidebar): Promise<NavigationResult> {
  // Get all docs from filesystem
  const allDocs = await getDocsFromFilesystem();
  const filesystemStructure = buildFilesystemStructure(allDocs);

  // Map configuration items (Group or bare Entry) into processed items while preserving original order
  const orderedConfigItems = config.groups.map((item: any, idx: number) => {
    if (item && (item as any).slug) {
      const entrySlug = (item as any).slug as string;
      const doc = allDocs.find((d) => d.slug === entrySlug);
      if (!doc) {
        console.warn(`Top-level entry ${entrySlug} not found in docs collection`);
        return null;
      }
      if (item.hidden || doc.data.navHidden) return null;

      return {
        type: "entry",
        index: idx,
        entry: {
          slug: entrySlug,
          label: (item as any).label || doc.data.navLabel || doc.data.title,
          icon: (item as any).icon || doc.data.navIcon,
          hidden: false,
          order: doc.data.navOrder,
        } as ProcessedEntry,
      };
    }

    // Process group
    const processed = processGroup(item as Group, filesystemStructure, allDocs);
    return { type: "group", index: idx, group: processed } as any;
  }).filter(Boolean) as Array<{ type: "entry" | "group"; index: number; entry?: ProcessedEntry; group?: ProcessedGroup }>;

  // Extract processed groups for tab computations (from orderedConfigItems)
  const processedGroups = orderedConfigItems
    .filter((i) => i?.type === "group")
    .map((i) => (i as any).group as ProcessedGroup);

  // Collect all tabs recursively (including nested groups with tab: true)
  function collectTabs(groups: ProcessedGroup[]): ProcessedGroup[] {
    const tabs: ProcessedGroup[] = [];

    groups.forEach((group) => {
      if (group.tab === true) {
        tabs.push(group);
      }
      // Recursively check subgroups
      if (group.groups && group.groups.length > 0) {
        tabs.push(...collectTabs(group.groups));
      }
    });

    return tabs;
  }

  // Collect all groups that should be tabs (at any level)
  const allTabGroups = collectTabs(processedGroups);

  // Remove tab groups from their parent groups and clean up the hierarchy
  function removeTabGroups(groups: ProcessedGroup[]): ProcessedGroup[] {
    return groups
      .filter((group) => group.tab !== true)
      .map((group) => {
        if (group.groups && group.groups.length > 0) {
          // Filter out groups that are tabs and recursively process remaining groups
          const nonTabSubgroups = group.groups.filter((g) => g.tab !== true);
          return {
            ...group,
            groups: removeTabGroups(nonTabSubgroups),
          };
        }
        return group;
      });
  }

  // For tabs that have subgroups, also remove nested tabs from their structure
  const cleanedTabGroups = allTabGroups.map((tabGroup) => {
    if (tabGroup.groups && tabGroup.groups.length > 0) {
      const nonTabSubgroups = tabGroup.groups.filter((g) => g.tab !== true);
      return {
        ...tabGroup,
        groups: removeTabGroups(nonTabSubgroups),
      };
    }
    return tabGroup;
  });

  // Get non-tab groups (with tab groups removed from hierarchy)
  const defaultGroups = removeTabGroups(processedGroups);

  // Create tabs
  const tabs: Tab[] = cleanedTabGroups.map((group) => ({
    id: group.id,
    label: group.label,
    icon: group.icon,
    group: group,
  }));

  // Create default tab if there are non-tab groups
  let defaultTab: Tab | undefined;
  if (defaultGroups.length > 0) {
    // Collect all existing slugs from processed groups to avoid duplicates
    const existingSlugs = new Set<string>();
    function collectSlugs(groups: ProcessedGroup[]) {
      groups.forEach((g) => {
        (g.entries || []).forEach((e) => existingSlugs.add(e.slug));
        if (g.groups && g.groups.length) collectSlugs(g.groups);
      });
    }
    collectSlugs(defaultGroups);

    // Build ordered children: iterate original orderedConfigItems to preserve configured ordering
    const defaultChildren: Array<ProcessedGroup | ProcessedEntry> = [];

    orderedConfigItems.forEach((item) => {
      if (item.type === "entry" && item.entry) {
        const entry = item.entry;
        if (!existingSlugs.has(entry.slug)) {
          defaultChildren.push(entry);
          existingSlugs.add(entry.slug);
        }
      } else if (item.type === "group" && item.group) {
        const group = item.group;
        if (group.tab !== true) {
          const cleaned = {
            ...group,
            groups: removeTabGroups(group.groups || []),
          } as ProcessedGroup;
          defaultChildren.push(cleaned);
        }
      }
    });

    // Add root-level docs as top-level entries (not grouped), excluding index and already included slugs
    const rootDocs = filesystemStructure.get("") || [];
    const rootEntries = rootDocs
      .filter((doc) => !doc.data.navHidden && doc.slug !== "index" && !existingSlugs.has(doc.slug))
      .map((doc) => ({
        slug: doc.slug,
        label: doc.data.navLabel || doc.data.title,
        icon: doc.data.navIcon,
        order: doc.data.navOrder,
      }))
      .sort((a, b) => a.label.localeCompare(b.label));

    // Finally append root entries (filesystem-root docs) after configured items
    const children = [...defaultChildren, ...rootEntries];

    defaultTab = {
      id: "_default",
      label: "Docs",
      group: {
        id: "_default",
        label: "Docs",
        groups: defaultGroups,
        entries: [],
        // ordered mix of entries and groups for rendering
        children: children as any,
      },
    };
  }

  // Determine if we should show tabs
  const visibleTabs = defaultTab ? [defaultTab, ...tabs] : tabs;
  const showTabs = visibleTabs.length >= 2;

  return {
    tabs: visibleTabs,
    showTabs,
    defaultTab,
  };
}

/**
 * Get the active tab based on the current page slug
 */
export function getActiveTab(slug: string, tabs: Tab[]): Tab | undefined {
  // Find which tab contains this slug
  for (const tab of tabs) {
    if (containsSlug(tab.group, slug)) {
      return tab;
    }
  }

  return tabs.find((t) => t.id === "_default") || tabs[0];
}

/**
 * Check if a group contains a specific slug
 */
function containsSlug(group: ProcessedGroup, slug: string): boolean {
  // Check direct entries
  if (group.entries?.some((e) => e.slug === slug)) {
    return true;
  }

  // Check subgroups recursively
  if (group.groups) {
    for (const subgroup of group.groups) {
      if (containsSlug(subgroup, slug)) {
        return true;
      }
    }
  }

  return false;
}
