import type { Group } from "../docs/types";

import { deriveLabel } from "./label.ts";
import type { ProcessedEntry, ProcessedGroup } from "./types";
import type { DocEntry } from "./types";

/**
 * Process a group and its entries according to autoGenerated rules
 *
 * Example Group input:
 * {
 *   id: 'guides',
 *   label: 'Guides',
 *   entries: [{ slug: 'guides/intro' }],
 *   groups: [{ id: 'advanced', entries: [...] }],
 *   autoGenerated: true
 * }
 *
 * Example ProcessedGroup output (fields added):
 * {
 *   id: 'guides',
 *   label: 'Guides',
 *   entries: [ { slug: 'guides/intro', label: 'Intro' }, ... ],
 *   groups: [ { id: 'advanced', entries: [...] } ]
 * }
 */
export function processGroup(
    group: Group,
    filesystemStructure: Map<string, DocEntry[]>,
    allDocs: DocEntry[],
): ProcessedGroup {
    const autoGenerated = group.autoGenerated ?? true;
    // Respect an explicit empty-string path (root) - if path is undefined use id
    const groupPath = group.path !== undefined ? group.path : group.id;

    // Get filesystem entries for this group's path
    const filesystemEntries = filesystemStructure.get(groupPath) || [];

    // Process configured entries
    const configuredEntries: ProcessedEntry[] = [];
    const configuredSlugs = new Set<string>();

    if (group.entries) {
        group.entries.forEach((entry) => {
            configuredSlugs.add(entry.slug);

            // Find the doc for this entry
            const doc = allDocs.find((d) => d.slug === entry.slug);

            if (!doc) {
                console.warn(`Entry ${entry.slug} not found in docs collection`);
                return;
            }

            // Skip hidden entries
            if (entry.hidden || doc.data.navHidden) {
                return;
            }

            configuredEntries.push({
                slug: entry.slug,
                // Prefer an explicit frontmatter `navLabel` on the document over labels configured
                // in `config.ts` so document metadata has the highest precedence.
                label: deriveLabel(doc, entry.label),
                icon: entry.icon || doc.data.navIcon,
                hidden: false,
            });
        });
    }

    // Handle auto-generated entries
    let finalEntries = [...configuredEntries];

    if (autoGenerated) {
        // Add unlisted filesystem entries
        const autoEntries: ProcessedEntry[] = filesystemEntries
            .filter((doc) => !configuredSlugs.has(doc.slug) && !doc.data.navHidden)
            .map((doc) => ({
                slug: doc.slug,
                label: deriveLabel(doc),
                icon: doc.data.navIcon,
            }))
            .sort((a, b) => a.label.localeCompare(b.label));

        finalEntries = [...configuredEntries, ...autoEntries];
    }

    // Process subgroups recursively
    const processedSubgroups: ProcessedGroup[] = [];
    if (group.groups) {
        group.groups.forEach((subgroup) => {
            processedSubgroups.push(processGroup(subgroup, filesystemStructure, allDocs));
        });
    }

    return {
        ...group,
        groups: processedSubgroups,
        entries: finalEntries,
    } as ProcessedGroup;
}
